# Задание 2

'''
На языке Python (2.7) реализовать минимум по 2 класса реализовывающих циклический 
буфер FIFO. Объяснить плюсы и минусы каждой реализации.

'''


# Первый способ
# Класс FIFO_1 создаёт список для объекта класса. Можно задать максимальную длину списка.
# Если список переполнен, то перед добавлением нового элемента удаляется самый старый элемент.

class FIFO_1:

    def __init__(self, length):
        """Задаёт максимальную длину списка и создаёт пустой список."""
        self.length = length
        self.mas = []

    def add_el(self, el):                   # Добавление элемента
        """Добавляет элемент в список"""
        if len(self.mas) >= self.length:    # Проверка длины списка
            self.mas.pop(0)                 # Удаление старого элемента
        self.mas.append(el)                 # Добавлние нового

    def remove_el(self):                    # Удаление старого элемента
        """Удаляет элемент из списка"""
        if self.mas != []:
            self.mas.pop(0)

a = FIFO_1(4)                               # Создаётся объект, задаётся максимальная длина

'''

Преимущества:

    + Простая реализация.

    + Возможность удалить элемент.

    + Скорость выполнения выше по сравнению со вторым решением.

    + Объём занимаемой памяти ниже по сравнению со вторым решением.


Недостатки:

    - Все элементы сдвигаются при добавлении нового.

'''


# Второй способ
# Класс FIFO_2 создаёт список для объекта класса. Можно задать максимальную длину списка.
# Если список переполнен, то перед добавлением нового элемента удаляется самый старый элемент.
# Новый элемент добавляется на позицию старого.

class FIFO_2:

    def __init__(self, length):
        """Задаёт максимальную длину списка и создаёт пустой список."""
        self.length = length
        self.mas = []
        self.n_el = 0                       # Позиция самого старого элемента

    def add_el(self, el):
        """Добавляет элемент в список"""
        if len(self.mas) < self.length:     # Проверка длины списка
            self.mas.insert(self.n_el, el)
        else:
            if self.n_el >= self.length:    # Изменение позиции старого элемента
                self.n_el = 0               # Обнуление номера старого элемента
            self.mas[self.n_el] = el        # Добавлние нового на позицию старого элемента
        self.n_el += 1

b = FIFO_2(4)                               # Создаётся объект, задаётся максимальная длина

'''

Преимущества:

    + При добавлении нового элемента старые элементы остаются на своих позициях.

Недостатки:

    - Наличие переменной, содержащей номер элемента, увеличивает требуемый объём памяти.

    - Наличие дополнительного условия замедляет выполнение скрипта.

    - Нет возможности удалить элемент, так как при удалении элемента меняется
    размер списка, и элементы сдвигаются. Можно было бы реализовать, используя специальный символ.
    Например, если элементы списка int, то использовать str для пустой ячейки.
    Или если все элементы списка положительные, то использовать отрицательное число для пустой ячейки.

'''


# Вывод на экран:

print('\nFIFO, первый способ:')
for i in range(1, 11):
    a.add_el(i)
    print(a.mas)
a.remove_el()
print(a.mas)
a.remove_el()
print(a.mas)


print('\nFIFO, второй способ:')
for i in range(1, 11):
    b.add_el(i)
    print(b.mas)
b.add_el(11)
print(b.mas)
b.add_el(12)
print(b.mas)